#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define ENABLE  1
#define DISABLE 0
#define PRINT_DEBUG DISABLE
#define FILE_CONTENT ENABLE

typedef  unsigned char UINT8;
typedef  unsigned int UINT32;


typedef struct
{
	UINT8 Offset;
	UINT8 Length;
	UINT8 NextWord;
	void *Forward;
	void *Backward;
} LZ77_NODE;

//112
#if FILE_CONTENT
UINT8 *FileContent = NULL;
UINT8 FileContentSize = 0;
#else 
//UINT8 FileContent[] = "504B03041400060008000000210065338683AD01000027080000130008025B436F6E74656E745F54797065735D2E786D6C20A2040228A000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000B455C96EDB3010BD07C83F08BC06129D1E8AA2B09C43976313A0E90750E44866C20DE438B1FFBE432F4210C896B3E822407AF39619129AF9CDDA9AE20962D2DED5ECBA9AB1029CF44ABBAE66FFEE7F97DF58915038258C7750B30D2476B3B8BC98DF6F02A482D82ED56C8918BE739EE412AC48950FE008697DB402E935763C08F9283AE05F66B3AF5C7A87E0B0C4ACC116F39FD08A95C1E2D79A3EEF9234DAB1E2C7AE2E5BD54C8460B41448307F72EA9549E9DB564B505EAE2C512A6FE0B67900898C0FEA3F04E85E19689B036E81610ED87690B22E3332CC8960D2DB1AD94FAA22E6B6262D7548575470C42123C70D8EF33A3DDC4DFE4E8C5BBA14512B28EE44C43FC212CE9F7D54BC1FF169E3F123CA6A217A0929D16DB3A6EA112BB43B747C34875BD90622313F3F482F3D1A22E1C640FAFC043BDD717B4024C21401F6CAA3119EA1F93B598A17E2A3415AEFD1799CE2347AE9D110E0D444190ECA67CD01E2F534538078863FF989C6C01409F6D2A321901611EC9E1F9FC456E6942555DE451F122DB6F88EB60F7FFCCC2EA9E10011F5E993EE1D49FAC3FD415E0A0AD48037DFAEF9C57F000000FFFF0300504B0304140006000800000021001E911AB7EF0000004E0200000B0008025F72656C732F2E72656C7320A2040228A000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000AC92C16AC3300C40EF83FD83D1BD51DAC118A34E2F63D0DB18D907085B494C13DBD86AD7FEFD3CD8D8025DE96147CBD2D393D07A739C4675E0945DF01A96550D8ABD09D6F95EC35BFBBC78009585BCA53178D670E20C9BE6F666FDCA234929CA838B59158ACF1A0691F88898CDC013E52A44F6E5A70B692229CFD46324B3A39E7155D7F7987E33A09931D5D66A485B7B07AA3D45BE861DBACE197E0A663FB197332D908FC2DEB25DC454EA93B8328D6A29F52C1A6C302F259C9162AC0A1AF0BCD1EA7AA3BFA7C589852C09A109892FFB7C665C125AFEE78AE6193F36EF2159B45FE16F1B9C5D41F3010000FFFF0300504B030414000600080000002100AFFAF460CD0200003E0B00001C000801776F72642F5F72656C732F646F63756D656E742E786D6C2E72656C7320A2040128A0000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000DC565D4FDB30147D9FB4FF5045EA9E46BE5A5AD8305555D60D890FC1409B78991CFB3675486C633B4DCBAF9F9342091B8D8614F130A952EE3D69CE3DD7E73ACEC16899A59D0528CD04474EE0FA4E07381194F11839D757D39D3DA7A30DE614A782037256A09DD1E1FB7707979062631FD2732675C7B2708D9CB931F293E76932870C6B5748E0F6CE4CA80C1B9BAAD89398DCE218BCD0F7079EAA733887CF383BC71439EA98DAFA572B09FFC22D663346E048903C036E5E28E1B1CCD6B68458C56090930165780DF65CC8668EF7B286A0D7A688B9655229E3B74F424A5A6D7933C822EB856B54AE0D502232991B6B45AC442E2B7A2C2D43191442DD56B027094999AD55C41E15054F05A6AE9CCB117DD0F08B5114067B61F058EF5450DBCA97A501C571BAADE9567BD660CA3EF453CB8F886BB9B64918BE8DF7A19B4888B79A1FFE07E60783D799DF6ACFDAAC52A85B5FE54DC657725BAB6FECB335E7AB740D068D22DAD4C0F3D25CEBE6938E0DD424A2D585004EB930752B1E91C675687521B66C004B5B14851B0B11A7E0DAD9F772958E3446E603CEE467450C4AAAE80E75C3F0618B74431F9640F292BD8CF98229C1CBCA36C344327B914ACC580ADD7062137BBE55245AE48A002A20AA524251B00E30452AC155BC008AFCC9C4BF9826E371855845A8D4DAED8DBBE1D4FE324DB99B31A284163353AAB620F09D5CDB6BCA2285D5CA4605E3766F";
//UINT8 FileContent[] = "a5df8alroifdksoaksdlgkerofxksa87543sdasdassdaodrflasdasddas4d8a152asdas876wedsjfuiodsfu5j4mn5gheriogmrsdkfsdsda";
//UINT8 FileContent[] = "a5df8alroifdksoaksdlgkerofxksa87543sdasdassdaodrfl";
//UINT8 FileContent[] = "a5df8alroifdksoaksdlgkerofxksa875";
UINT8 FileContent[] = "a5df8alroifdks";
//UINT8 FileContent[] =   "a5df8alroifdksoaksd";
//UINT8 FileContent[] = "cabracadabrarrarrad";
UINT8 FileContentSize = sizeof(FileContent);
#endif

const UINT8 SearchBufferSize = 7;
const UINT8 LookAheadBufferSize = 6;

UINT8 *Headbuffer = NULL;
UINT8 *SearchBufferPointer;
UINT8 *LookAheadBufferPointer;
UINT8 *OffsetPointer;
UINT8 OffsetCounter = 0;
LZ77_NODE *FirstNode = NULL; 
LZ77_NODE *CurrentNode = NULL;

UINT8 *EndPoint;;

UINT32 strncmpReturnSameCharCount(UINT8* a, UINT8* b, UINT32 Length)
{
	UINT32 Index;
	for (Index = 0; Index < Length; Index++)
	{
		if (a[Index] != b[Index])
		{
			break;
		}
		else if (a[Index] == '\0')
		{
	    	return 0;
	    }
	}
	return Index;
}

void PrintNodeInfo (LZ77_NODE * Node)
{
	printf ("Node->Length		: %d\n", Node->Length);
	printf ("Node->Offset		: %d\n", Node->Offset);
	printf ("Node->NextWord 	: %c\n", Node->NextWord);	
}

void CleanAllNode()
{
	if (FirstNode != NULL)
	{
		CurrentNode = FirstNode;
		while (CurrentNode->Forward != NULL)
		{
#if PRINT_DEBUG			
			printf("Remove node: ");
			PrintNodeInfo (FirstNode);
#endif
			CurrentNode = (LZ77_NODE *)CurrentNode->Forward;
			CurrentNode->Backward = NULL;

			free(FirstNode);
			FirstNode = CurrentNode;
		}
#if PRINT_DEBUG			
		printf("Remove node: ");
		PrintNodeInfo (CurrentNode);
#endif
		free(CurrentNode);
		CurrentNode = NULL;
		FirstNode = NULL;
	}
	
	if (Headbuffer != NULL)
	{
		free(Headbuffer);
		Headbuffer = NULL;
	}
}

void EncodeLZ77()
{
#if PRINT_DEBUG
	printf ("================================================\n");
	printf ("============== EncodeLZ77 start ================\n");
	printf ("================================================\n");
#endif
	SearchBufferPointer = FileContent;
	LookAheadBufferPointer = SearchBufferPointer + SearchBufferSize;
	OffsetCounter = 0;

	Headbuffer = (UINT8 *) malloc(SearchBufferSize);
	memcpy (Headbuffer, SearchBufferPointer, SearchBufferSize);
	
	while (LookAheadBufferPointer <= EndPoint)
	{
		OffsetPointer = LookAheadBufferPointer - 1;
		LZ77_NODE * Tmp = (void *)malloc (sizeof(LZ77_NODE));
		Tmp->Offset = 0;
		Tmp->Length = 0;
		Tmp->NextWord = LookAheadBufferPointer[0];
		Tmp->Forward = NULL;
		Tmp->Backward = NULL;
		
		if (FirstNode == NULL)
		{
			FirstNode = Tmp;
			CurrentNode = FirstNode;	
		}
		else
		{
			CurrentNode->Forward = (LZ77_NODE *)Tmp;
			Tmp->Backward = (void *)CurrentNode;
			CurrentNode = Tmp;
		}
		
		int OffsetCounter = 0;
		for (OffsetCounter = 0; OffsetCounter < SearchBufferSize; OffsetCounter++)
		{
#if PRINT_DEBUG
			printf ("%2d. %c ?= %c \n",OffsetCounter, LookAheadBufferPointer[0], *OffsetPointer);
#endif
			if (LookAheadBufferPointer[0] == *OffsetPointer)
			{
				int CompareLength;
				if (EndPoint - LookAheadBufferPointer < LookAheadBufferSize)
				{
					CompareLength = EndPoint - LookAheadBufferPointer;
				}
				else
				{
					CompareLength = CompareLength;
				} 
				
				UINT8 Length = strncmpReturnSameCharCount(LookAheadBufferPointer, OffsetPointer, CompareLength + OffsetCounter);
				if (Tmp->Length < Length)
				{
					Tmp->Length = Length;
					Tmp->Offset = OffsetCounter + 1;
					if((LookAheadBufferPointer + Length) != EndPoint) 
					{
						Tmp->NextWord = LookAheadBufferPointer[Length];
					}
					else
					{
						Tmp->NextWord = 0;
					}

				}
			}
			OffsetPointer--;
		}
		
#if PRINT_DEBUG
		PrintNodeInfo (Tmp);
#endif
		
		// =====================================
		printf(" ============  Buffer Move ===============\n");
		SearchBufferPointer += Tmp->Length + 1 ;
		LookAheadBufferPointer = SearchBufferPointer + SearchBufferSize;
		OffsetCounter = 0;
	}
	
#if PRINT_DEBUG
	printf ("================================================\n");
	printf ("============== EncodeLZ77 end ================\n");
	printf ("================================================\n");
#endif
}

void DecodeLZ77()
{
#if PRINT_DEBUG
	printf ("================================================\n");
	printf ("============== DecodeLZ77 start ================\n");
	printf ("================================================\n");
#endif
	
	int TotalBufferDataLength = SearchBufferSize;
	UINT8 *OutPutDataBuffer = NULL;
	UINT8 *OuputPointer;
	UINT8 *OffsetPointer;
	
	// Count full size
	CurrentNode = FirstNode;
	while (CurrentNode != NULL)
	{
		TotalBufferDataLength += CurrentNode->Length + 1;
		CurrentNode = (LZ77_NODE *)CurrentNode->Forward;
	}
#if PRINT_DEBUG
	printf("TotalBufferDataLength : %d\n", TotalBufferDataLength);
	printf("FileContent           : %d\n", FileContentSize);
#endif
	
	OutPutDataBuffer = (UINT8 *)malloc(TotalBufferDataLength);
	memset (OutPutDataBuffer, 0 , TotalBufferDataLength);
	
	OuputPointer = OutPutDataBuffer;
	memcpy (OuputPointer, Headbuffer, SearchBufferSize);
	OuputPointer += SearchBufferSize;
	
	CurrentNode = FirstNode;
	while (CurrentNode != NULL)
	{
		OffsetPointer = OuputPointer - CurrentNode->Offset;
		int Index;
		for (Index = 0; Index < CurrentNode->Length; Index++)
		{
			*OuputPointer++ = *OffsetPointer++;
		}

		*OuputPointer = CurrentNode->NextWord;
		OuputPointer++;
		
		CurrentNode = (LZ77_NODE *)CurrentNode->Forward;
	}
#if PRINT_DEBUG	
	printf ("OutPutDataBuffer : %s\n", OutPutDataBuffer);
	printf ("FileContent      : %s\n", FileContent);
#endif
	
	// =========== ending ========
	if (OutPutDataBuffer != NULL)
	{
		free(OutPutDataBuffer);
	}
	
#if PRINT_DEBUG
	printf ("================================================\n");
	printf ("============== DecodeLZ77 end ================\n");
	printf ("================================================\n");
#endif
}


char FileName[] = "images.jpg";
void FileOpen()
{
#if FILE_CONTENT
	FILE *InputFile = fopen(FileName, "rb") ;
	
	unsigned long Position = ftell(InputFile);
	
	fseek(InputFile, 0, SEEK_END);
	FileContentSize = ftell(InputFile);
	
	fseek(InputFile, Position, SEEK_SET);
	printf("FileContentSize %d\n", FileContentSize);
	
	FileContent = (UINT8 *)malloc(FileContentSize);
	fread (FileContent, 1, FileContentSize, InputFile);
	
	if (InputFile != NULL)
	{
		fclose(InputFile);
	}
#endif

	EndPoint =  FileContent + FileContentSize -1;
} 


int main ()
{
	FileOpen();
	
	EncodeLZ77();

	DecodeLZ77();
	
	// Clean AllNode
	CleanAllNode();
	
#if FILE_CONTENT
	free(FileContent);
#endif
	return 0;
}
